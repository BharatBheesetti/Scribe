---
phase: 06-cicd-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .github/workflows/release.yml
  - src-tauri/tauri.conf.json
autonomous: true

must_haves:
  truths:
    - "Pushing a v*.*.* tag triggers the release workflow on GitHub Actions"
    - "Workflow installs LLVM, CMake, Rust, Node.js on a clean Windows runner"
    - "Cargo tests run and gate the build (failure stops the pipeline)"
    - "Version is extracted from git tag and synced to Cargo.toml before build"
    - "tauri-action builds the NSIS installer"
    - "GitHub Release is created with installer + SHA256 checksums attached"
    - "Release notes are auto-generated from commits since last tag"
    - "Rust dependency caching via rust-cache reduces rebuild time"
  artifacts:
    - path: ".github/workflows/release.yml"
      provides: "Complete CI/CD release pipeline"
      contains: "on:\\n  push:\\n    tags:"
    - path: "src-tauri/tauri.conf.json"
      provides: "Tauri config without hardcoded version"
  key_links:
    - from: ".github/workflows/release.yml"
      to: "src-tauri/Cargo.toml"
      via: "sed version sync from git tag"
      pattern: "sed.*version.*Cargo.toml"
    - from: ".github/workflows/release.yml"
      to: "src-tauri/target/x86_64-pc-windows-msvc/release/bundle/nsis/*.exe"
      via: "tauri-action build output"
      pattern: "tauri-apps/tauri-action"
    - from: ".github/workflows/release.yml"
      to: "GitHub Releases"
      via: "gh release create or tauri-action release"
      pattern: "GITHUB_TOKEN"
---

<objective>
Create the complete GitHub Actions release workflow and configure Tauri for CI builds.

Purpose: This is the entire CI/CD pipeline for Scribe. When a semver tag (v*.*.*) is pushed, GitHub Actions builds the NSIS installer on a clean Windows runner with the whisper-rs/LLVM toolchain, runs all 151 tests as a gate, creates a GitHub Release with the installer attached plus SHA256 checksums, and auto-generates release notes from commits.

Output: A working `.github/workflows/release.yml` and an updated `tauri.conf.json` ready for CI.
</objective>

<execution_context>
@C:\Users\bhara\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\bhara\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-cicd-pipeline/06-CONTEXT.md
@.planning/phases/06-cicd-pipeline/06-RESEARCH.md
@src-tauri/Cargo.toml
@src-tauri/tauri.conf.json
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure tauri.conf.json for CI compatibility</name>
  <files>src-tauri/tauri.conf.json</files>
  <action>
  Modify src-tauri/tauri.conf.json to prepare for CI builds:

  1. Remove the "version" field from the top level. Tauri v2 defaults to reading version from Cargo.toml when this field is absent. This makes Cargo.toml the single source of truth, which the workflow will sync from the git tag.

  2. In the "bundle" section, set NSIS-specific configuration so the installer filename is `Scribe-setup.exe` (no version in filename). Add an "nsis" section under "bundle" if not present:
     ```json
     "nsis": {
       "displayLanguageSelector": false
     }
     ```

  3. Ensure "bundle.targets" is set to "nsis" (not "all") to avoid trying to build MSI or other formats in CI. Actually, check: if "all" includes NSIS on Windows, keep "all" since tauri-action handles target selection. The key is that NSIS must be included. Leave as "all" -- tauri-action on Windows will produce NSIS.

  4. Verify the "bundle.icon" path points to an existing icon file. Check that `src-tauri/icons/icon.png` exists. If not, note it but don't block -- the icon was added in Phase 2A.

  Do NOT change: app windows config, security CSP, plugins, build commands. Only touch version and bundle/nsis config.

  Why remove version: The workflow syncs version from the git tag to Cargo.toml. If tauri.conf.json also has a version, they can conflict. Research (06-RESEARCH.md Pitfall 2) confirms omitting version from tauri.conf.json is the correct approach.
  </action>
  <verify>
  Read the modified tauri.conf.json and confirm:
  - No "version" field at the top level
  - "nsis" section exists under "bundle"
  - All other fields unchanged
  - File is valid JSON (parse it)
  </verify>
  <done>tauri.conf.json has no hardcoded version field and has NSIS bundle configuration. Cargo.toml is the single version source of truth.</done>
</task>

<task type="auto">
  <name>Task 2: Create the release workflow</name>
  <files>.github/workflows/release.yml</files>
  <action>
  Create `.github/workflows/release.yml` implementing the full release pipeline. The workflow structure comes from 06-RESEARCH.md but needs careful assembly.

  **Trigger:**
  ```yaml
  on:
    push:
      tags:
        - 'v[0-9]+.[0-9]+.[0-9]+'
  ```
  This matches only stable semver tags (v1.0.0, v1.1.0, etc.) -- no pre-releases.

  **Permissions:**
  ```yaml
  permissions:
    contents: write
  ```
  Required for creating releases and uploading assets.

  **Single job: `release`** on `windows-latest`.

  **Steps in order:**

  1. **Checkout** - `actions/checkout@v4`

  2. **Extract version from tag** - Strip the `v` prefix from the tag.
     ```yaml
     - name: Get version from tag
       id: version
       run: echo "VERSION=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT
       shell: bash
     ```

  3. **Sync version to Cargo.toml** - Use sed to update the version line in src-tauri/Cargo.toml.
     ```yaml
     - name: Sync version to Cargo.toml
       run: sed -i "s/^version = \".*\"/version = \"${{ steps.version.outputs.VERSION }}\"/" src-tauri/Cargo.toml
       shell: bash
     ```

  4. **Verify version sync** - Grep to confirm the version was written correctly. Fail the build if mismatch.
     ```yaml
     - name: Verify version sync
       run: |
         grep -q "^version = \"${{ steps.version.outputs.VERSION }}\"" src-tauri/Cargo.toml || { echo "ERROR: Version sync failed"; exit 1; }
       shell: bash
     ```

  5. **Install Rust** - `dtolnay/rust-toolchain@stable`

  6. **Install LLVM** - `KyleMayes/install-llvm-action@latest` with version "18". This is CRITICAL for whisper-rs-sys compilation. The action automatically sets LIBCLANG_PATH.

  7. **Rust cache** - `Swatinem/rust-cache@v2` with `workspaces: src-tauri` and `cache-on-failure: true`. This caches Cargo dependencies (tauri, cpal, reqwest, etc.) but NOT whisper.cpp build artifacts. Satisfies CICD-04.

  8. **Install Node.js** - `actions/setup-node@v4` with `node-version: lts/*` and `cache: npm`.

  9. **Install npm dependencies** - `npm ci`

  10. **Run tests** - `cargo test --manifest-path=src-tauri/Cargo.toml`. This is the test gate. All 151 tests must pass. If tests fail, the workflow stops here and no release is created.

  11. **Build with tauri-action** - `tauri-apps/tauri-action@v0`. Configure:
      - `env.GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}`
      - `tagName: ${{ github.ref_name }}`
      - `releaseName: "Scribe ${{ steps.version.outputs.VERSION }}"`
      - `releaseBody: ""` (empty -- we will use auto-generated notes)
      - `releaseDraft: false`
      - `prerelease: false`

      NOTE: tauri-action creates the GitHub Release AND uploads the NSIS installer. This covers CICD-02 (installer artifact) and CICD-03 (GitHub Release).

      IMPORTANT: The tauri-action `releaseBody` field does NOT support auto-generated release notes. We need a different approach for CICD-05. Instead of using tauri-action's release creation, we have two options:
      - Option A: Let tauri-action create the release with a placeholder body, then update it with auto-generated notes
      - Option B: Use tauri-action with `tauriScript` to only BUILD (not release), then create the release ourselves with `gh release create --generate-notes`

      **Use Option A:** Let tauri-action handle the full flow (build + release + asset upload), then add a step to update release notes. This is simpler and uses tauri-action as designed.

      Actually, check tauri-action docs: it may support `generateReleaseNotes: true` or similar. The `softprops/action-gh-release` action supports this. If tauri-action does not, use this alternative approach:

      **Use tauri-action with `includeRelease: false` and `includeUpdaterJson: false`** to only build, then create the release separately. Wait -- tauri-action may not have these flags.

      **Simplest approach:** Let tauri-action create the release. Then immediately after, use `gh` CLI to edit the release and regenerate notes:
      ```yaml
      - name: Update release with auto-generated notes
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release edit ${{ github.ref_name }} --notes ""
          gh release edit ${{ github.ref_name }} --generate-notes
        shell: bash
      ```

      This satisfies CICD-05 (auto-generated release notes from commits).

  12. **Generate SHA256 checksums** - After tauri-action completes and uploads the installer, generate a checksums file:
      ```yaml
      - name: Generate SHA256 checksums
        run: |
          cd src-tauri/target/x86_64-pc-windows-msvc/release/bundle/nsis
          $files = Get-ChildItem -Filter "*.exe"
          foreach ($file in $files) {
            $hash = (Get-FileHash $file -Algorithm SHA256).Hash
            "$hash  $($file.Name)" | Add-Content -Path "SHA256SUMS.txt"
          }
        shell: pwsh
      ```

  13. **Upload checksums to release** - Use gh CLI to attach the checksums file:
      ```yaml
      - name: Upload checksums to release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: gh release upload ${{ github.ref_name }} src-tauri/target/x86_64-pc-windows-msvc/release/bundle/nsis/SHA256SUMS.txt --clobber
        shell: bash
      ```

  **Do NOT include:**
  - workflow_dispatch trigger (context says tags only)
  - ARM64 or Linux/macOS builds (Windows x64 only)
  - Pre-release logic
  - Draft release logic
  - Debug symbol uploads
  - LLVM/CMake caching (research says not recommended)

  **Formatting:** Use clean YAML with comments explaining non-obvious steps. Group related steps with comment headers (# Version sync, # Toolchain setup, # Build and release, # Post-release).
  </action>
  <verify>
  1. Validate YAML syntax: Use a YAML linter or parse the file to confirm no syntax errors.
     Run: `npx yaml-lint .github/workflows/release.yml` or use Python: `python -c "import yaml; yaml.safe_load(open('.github/workflows/release.yml'))"`

  2. Verify the workflow contains all required elements:
     - Trigger on tag push matching v[0-9]+.[0-9]+.[0-9]+
     - permissions: contents: write
     - Version extraction step with id: version
     - sed command updating Cargo.toml
     - Version verification step
     - dtolnay/rust-toolchain@stable
     - KyleMayes/install-llvm-action with version "18"
     - Swatinem/rust-cache@v2 with workspaces: src-tauri
     - actions/setup-node@v4
     - npm ci
     - cargo test with --manifest-path
     - tauri-apps/tauri-action@v0
     - SHA256 checksum generation
     - Checksum upload via gh release upload
     - Release notes update via gh release edit --generate-notes

  3. Confirm no hardcoded version numbers in the workflow (all should reference steps.version.outputs.VERSION or github.ref_name).
  </verify>
  <done>
  .github/workflows/release.yml exists with:
  - Tag-triggered pipeline (v*.*.* only)
  - LLVM 18 + Rust stable + Node.js LTS toolchain setup
  - Version sync from tag to Cargo.toml with verification
  - cargo test gate (151 tests)
  - tauri-action NSIS build + GitHub Release creation
  - Auto-generated release notes (gh release edit --generate-notes)
  - SHA256 checksums file attached to release
  - rust-cache for dependency caching
  All five CICD requirements (01-05) addressed in a single workflow file.
  </done>
</task>

</tasks>

<verification>
After both tasks complete, verify the full phase:

1. `.github/workflows/release.yml` exists and is valid YAML
2. `src-tauri/tauri.conf.json` has no "version" field at top level
3. The workflow covers all 5 requirements:
   - CICD-01: Tag push triggers build (check `on.push.tags`)
   - CICD-02: NSIS installer produced (check tauri-action step)
   - CICD-03: GitHub Release created with installer (check tauri-action config)
   - CICD-04: Rust cache enabled (check rust-cache step)
   - CICD-05: Auto-generated release notes (check gh release edit step)
4. Test gate exists before build (cargo test step precedes tauri-action)
5. SHA256 checksums generated and uploaded
6. No hardcoded versions in workflow
7. LIBCLANG_PATH handled by install-llvm-action
</verification>

<success_criteria>
- `.github/workflows/release.yml` is a complete, valid GitHub Actions workflow
- `src-tauri/tauri.conf.json` uses Cargo.toml as version source of truth
- All 5 CICD requirements (01-05) are satisfied
- Workflow is ready to execute on next `git tag v*.*.* && git push --tags`
</success_criteria>

<output>
After completion, create `.planning/phases/06-cicd-pipeline/06-01-SUMMARY.md`
</output>
